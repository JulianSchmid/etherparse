use super::super::*;

/// IPv6 fragment header.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Ipv6FragmentHeader {
    /// IP protocol number specifying the next header or transport layer protocol.
    ///
    /// See [IpNumber] or [ip_number] for a definition of the known values.
    pub next_header: u8,
    /// Offset in 8 octets
    ///
    /// Note: In the header only 13 bits are used, so the allowed range
    /// of the value is between 0 and 0x1FFF (inclusive).
    pub fragment_offset: u16,
    /// True if more fragment packets will follow. False if this is the last packet.
    pub more_fragments: bool,
    /// Identifcation value generated by the source.
    pub identification: u32,
}

impl Ipv6FragmentHeader {
    /// Length of the serialized header.
    pub const LEN: usize = 8;

    /// Create a new fragmentation header with the given parameters.
    ///
    /// Note that the `fragment_offset` can only support values between 0 and 0x1fff (inclusive).
    pub const fn new(
        next_header: u8,
        fragment_offset: u16,
        more_fragments: bool,
        identification: u32,
    ) -> Ipv6FragmentHeader {
        Ipv6FragmentHeader {
            next_header,
            fragment_offset,
            more_fragments,
            identification,
        }
    }

    /// Read an Ipv6FragmentHeader from a slice and return the header & unused parts of the slice.
    pub fn from_slice(
        slice: &[u8],
    ) -> Result<(Ipv6FragmentHeader, &[u8]), err::UnexpectedEndOfSliceError> {
        let s = Ipv6FragmentHeaderSlice::from_slice(slice)?;
        let rest = &slice[8..];
        let header = s.to_header();
        Ok((header, rest))
    }

    /// Read an fragment header from the current reader position.
    pub fn read<T: io::Read + io::Seek + Sized>(
        reader: &mut T,
    ) -> Result<Ipv6FragmentHeader, ReadError> {
        let buffer = {
            let mut buffer: [u8; 8] = [0; 8];
            reader.read_exact(&mut buffer)?;
            buffer
        };

        Ok(Ipv6FragmentHeader {
            next_header: buffer[0],
            fragment_offset: u16::from_be_bytes([
                (buffer[2] >> 3) & 0b0001_1111u8,
                ((buffer[2] << 5) & 0b1110_0000u8) | (buffer[3] & 0b0001_1111u8),
            ]),
            more_fragments: 0 != buffer[3] & 0b1000_0000u8,
            identification: u32::from_be_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
        })
    }

    /// Writes a given IPv6 fragment header to the current position.
    pub fn write<T: io::Write + Sized>(&self, writer: &mut T) -> Result<(), WriteError> {
        Ok(writer.write_all(&self.to_bytes()?)?)
    }

    /// Length of the header in bytes.
    #[inline]
    pub fn header_len(&self) -> usize {
        Ipv6FragmentHeader::LEN
    }

    /// Checks if the fragment header actually fragments the packet.
    ///
    /// Returns false if the fragment offset is 0 and the more flag
    /// is not set. Otherwise returns true.
    ///
    /// [RFC8200](https://datatracker.ietf.org/doc/html/rfc8200) explicitly
    /// states that fragment headers that don't fragment the packet payload are
    /// allowed. See the following quote from
    /// RFC8200 page 32:
    ///
    /// > Revised the text to handle the case of fragments that are whole
    /// > datagrams (i.e., both the Fragment Offset field and the M flag
    /// > are zero).  If received, they should be processed as a
    /// > reassembled packet.  Any other fragments that match should be
    /// > processed independently.  The Fragment creation process was
    /// > modified to not create whole datagram fragments (Fragment
    /// > Offset field and the M flag are zero).  See
    /// > [RFC6946](https://datatracker.ietf.org/doc/html/6946) and
    /// > [RFC8021](https://datatracker.ietf.org/doc/html/rfc8021) for more
    /// > information."
    ///
    /// ```
    /// use etherparse::{Ipv6FragmentHeader, ip_number::UDP};
    ///
    /// // offset 0 & no more fragments result in an unfragmented payload
    /// {
    ///     let header = Ipv6FragmentHeader::new(UDP, 0, false, 123);
    ///     assert!(false == header.is_fragmenting_payload());
    /// }
    ///
    /// // offset 0 & but more fragments will come -> fragmented
    /// {
    ///     let header = Ipv6FragmentHeader::new(UDP, 0, true, 123);
    ///     assert!(header.is_fragmenting_payload());
    /// }
    ///
    /// // offset non zero & no more fragments will come -> fragmented
    /// {
    ///     let header = Ipv6FragmentHeader::new(UDP, 1, false, 123);
    ///     assert!(header.is_fragmenting_payload());
    /// }
    /// ```
    #[inline]
    pub fn is_fragmenting_payload(&self) -> bool {
        self.more_fragments || (0 != self.fragment_offset)
    }

    /// Returns the serialized form of the header as a statically
    /// sized byte array.
    ///
    /// The `fragment_offset` is only allowed to have the maximum
    /// size of `0x1FFF`.
    #[inline]
    pub fn to_bytes(&self) -> Result<[u8; 8], ValueError> {
        use ErrorField::*;

        max_check_u16(
            self.fragment_offset,
            0b0001_1111_1111_1111u16,
            Ipv6FragmentOffset,
        )?;

        let fo_be: [u8; 2] = self.fragment_offset.to_be_bytes();
        let id_be = self.identification.to_be_bytes();
        Ok([
            self.next_header,
            0,
            (((fo_be[0] << 3) & 0b1111_1000u8) | ((fo_be[1] >> 5) & 0b0000_0111u8)),
            ((fo_be[1] & 0b0001_1111u8)
                | if self.more_fragments {
                    0b1000_0000u8
                } else {
                    0
                }),
            id_be[0],
            id_be[1],
            id_be[2],
            id_be[3],
        ])
    }
}

#[cfg(test)]
mod test {
    use crate::{*, test_gens::*};
    use proptest::prelude::*;
    use std::io::Cursor;

    proptest! {
        #[test]
        fn debug(input in ipv6_fragment_any()) {
            assert_eq!(
                &format!(
                    "Ipv6FragmentHeader {{ next_header: {}, fragment_offset: {}, more_fragments: {}, identification: {} }}",
                    input.next_header,
                    input.fragment_offset,
                    input.more_fragments,
                    input.identification
                ),
                &format!("{:?}", input)
            );
        }
    }

    proptest! {
        #[test]
        fn clone_eq(input in ipv6_fragment_any()) {
            assert_eq!(input, input.clone());
        }
    }

    proptest! {
        #[test]
        fn new(
            next_header in any::<u8>(),
            fragment_offset in any::<u16>(),
            more_fragments in any::<bool>(),
            identification in any::<u32>(),
        ) {
            let a = Ipv6FragmentHeader::new(
                next_header,
                fragment_offset,
                more_fragments,
                identification
            );
            assert_eq!(next_header, a.next_header);
            assert_eq!(fragment_offset, a.fragment_offset);
            assert_eq!(more_fragments, a.more_fragments);
            assert_eq!(identification, a.identification);
        }
    }

    proptest! {
        #[test]
        fn from_slice(
            input in ipv6_fragment_any(),
            dummy_data in proptest::collection::vec(any::<u8>(), 0..20)
        ) {
            // serialize
            let mut buffer: Vec<u8> = Vec::with_capacity(8 + dummy_data.len());
            input.write(&mut buffer).unwrap();
            buffer.extend(&dummy_data[..]);

            // calls with a valid result
            {
                let (result, rest) = Ipv6FragmentHeader::from_slice(&buffer[..]).unwrap();
                assert_eq!(input, result);
                assert_eq!(&buffer[8..], rest);
            }
            // call with not enough data in the slice
            for len in 0..Ipv6FragmentHeader::LEN {
                assert_eq!(
                    Ipv6FragmentHeader::from_slice(&buffer[0..len]).unwrap_err(),
                    err::UnexpectedEndOfSliceError{
                        expected_min_len: Ipv6FragmentHeader::LEN,
                        actual_len: len,
                        layer: err::Layer::Ipv6FragHeader,
                    }
                );
            }
        }
    }

    proptest! {
        #[test]
        fn read(
            input in ipv6_fragment_any(),
            dummy_data in proptest::collection::vec(any::<u8>(), 0..20)
        ) {
            use std::io::ErrorKind;

            // serialize
            let mut buffer: Vec<u8> = Vec::with_capacity(8 + dummy_data.len());
            input.write(&mut buffer).unwrap();
            buffer.extend(&dummy_data[..]);

            // calls with a valid result
            {
                let mut cursor = Cursor::new(&buffer);
                let result = Ipv6FragmentHeader::read(&mut cursor).unwrap();
                assert_eq!(input, result);
                assert_eq!(cursor.position(), 8);
            }

            // call with not enough data in the slice
            for len in 0..Ipv6FragmentHeader::LEN {
                let mut cursor = Cursor::new(&buffer[0..len]);
                assert_eq!(
                    Ipv6FragmentHeader::read(&mut cursor)
                    .unwrap_err()
                    .io_error()
                    .unwrap()
                    .kind(),
                    ErrorKind::UnexpectedEof
                );
            }
        }
    }

    proptest! {
        #[test]
        fn write(input in ipv6_fragment_any()) {

            // normal write
            {
                let mut buffer = Vec::with_capacity(8);
                input.write(&mut buffer).unwrap();
                assert_eq!(
                    &buffer,
                    &input.to_bytes().unwrap()
                );
            }

            // too big fragment offset
            for i in 0b001..=0b111u16 {
                use crate::ValueError::*;
                use crate::ErrorField::*;

                let fragment_offset = input.fragment_offset | (i << 13);

                let input_with_bad_frag_off = {
                    let mut re = input.clone();
                    re.fragment_offset = fragment_offset;
                    re
                };

                let mut buffer = Vec::with_capacity(8);
                assert_eq!(
                    input_with_bad_frag_off
                        .write(&mut buffer)
                        .unwrap_err()
                        .value_error()
                        .unwrap(),
                    U16TooLarge{
                        value: fragment_offset,
                        max: 0b0001_1111_1111_1111,
                        field: Ipv6FragmentOffset
                    }
                );
            }

            // not enough memory for write
            for len in 0..Ipv6FragmentHeader::LEN {
                let mut buffer = [0u8;Ipv6FragmentHeader::LEN];
                let mut cursor = Cursor::new(&mut buffer[..len]);
                assert!(
                    input.write(&mut cursor).unwrap_err().io_error().is_some()
                );
            }
        }
    }

    proptest! {
        #[test]
        fn header_len(input in ipv6_fragment_any()) {
            assert_eq!(8, input.header_len());
        }
    }

    proptest! {
        #[test]
        fn is_fragmenting_payload(
            non_zero_offset in 1u16..0b0001_1111_1111_1111u16,
            identification in any::<u32>(),
            next_header in any::<u8>(),

        ) {
            // negative case
            {
                let header = Ipv6FragmentHeader {
                    next_header,
                    fragment_offset: 0,
                    more_fragments: false,
                    identification
                };
                assert!(false == header.is_fragmenting_payload());
            }
            // positive case (non zero offset)
            {
                let header = Ipv6FragmentHeader {
                    next_header,
                    fragment_offset: non_zero_offset,
                    more_fragments: false,
                    identification
                };
                assert!(header.is_fragmenting_payload());
            }

            // positive case (more fragments)
            {
                let header = Ipv6FragmentHeader {
                    next_header,
                    fragment_offset: 0,
                    more_fragments: true,
                    identification
                };
                assert!(header.is_fragmenting_payload());
            }

            // positive case (non zero offset & more fragments)
            {
                let header = Ipv6FragmentHeader {
                    next_header,
                    fragment_offset: non_zero_offset,
                    more_fragments: true,
                    identification
                };
                assert!(header.is_fragmenting_payload());
            }
        }
    }

    proptest! {
        #[test]
        fn to_bytes(input in ipv6_fragment_any()) {

            // normal write
            {
                let fragment_offset_be = input.fragment_offset.to_be_bytes();
                let id_be = input.identification.to_be_bytes();
                assert_eq!(
                    &input.to_bytes().unwrap(),
                    &[
                        input.next_header,
                        0,
                        (
                            (fragment_offset_be[0] << 3 & 0b1111_1000u8) |
                            (fragment_offset_be[1] >> 5 & 0b0000_0111u8)
                        ),
                        (
                            (fragment_offset_be[1] & 0b0001_1111u8) |
                            if input.more_fragments {
                                0b1000_0000u8
                            } else {
                                0u8
                            }
                        ),
                        id_be[0],
                        id_be[1],
                        id_be[2],
                        id_be[3],
                    ]
                );
            }

            // too big fragment offset
            for i in 0b001..=0b111u16 {
                use crate::ValueError::*;
                use crate::ErrorField::*;

                let fragment_offset = input.fragment_offset | (i << 13);

                let input_with_bad_frag_off = {
                    let mut re = input.clone();
                    re.fragment_offset = fragment_offset;
                    re
                };

                assert_eq!(
                    input_with_bad_frag_off
                        .to_bytes()
                        .unwrap_err(),
                    U16TooLarge{
                        value: fragment_offset,
                        max: 0b0001_1111_1111_1111,
                        field: Ipv6FragmentOffset
                    }
                );
            }
        }
    }
}